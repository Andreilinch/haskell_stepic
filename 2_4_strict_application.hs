-- Использование seq иногда не очень удобно, поэтому в Haskell определен
-- специальный оператор аппликации с вызовом по значению, который позволяет более 
-- удобно использовать форсированный вычисления


-- ($!) :: (a -> b) -> a -> b
-- f $! x = x `seq` f x -- f применяется к своему аргументу, но при этом аргумент вычисляется

-- то есть x приводится к whnf

-- Пример
-- *Main> const 42 undefined
-- 42

-- *Main> const 42 $ undefined
-- 42

-- *Main> const 42 $! undefined
-- *** Exception: Prelude.undefined

-- Посмотрим как удается избежать накопления отложенных вычислений с помощью 
-- этого оператор на примере функции факториала из первого модуля

factorial :: Integer -> Integer
factorial n | n >= 0 = helper 1 n
            | otherwise = error "arg must be >= 0"
  where  
    helper acc 0 = acc 
    helper acc n = helper (acc * n) (n - 1)

-- (acc * n) здесь будет накоплена вся цепочка вычислений

factorial' :: Integer -> Integer
factorial' n | n >= 0 = helper 1 n
             | otherwise = error "arg must be >= 0"
  where  
    helper acc 0 = acc 
    helper acc n = (helper $! (acc * n)) (n - 1)

-- теперь (acc * n) вычисляется на каждом шаге

-- Задача
-- Ниже определены функции mySum и goSum. Вызов goSum может выглядеть, 
-- к примеру, так:  goSum 15. Выберите верные утверждения, 
-- описывающие процесс вычисления подобного выражения.

mySum acc 0 = acc
mySum (result, ()) n = (mySum $! (result + n, ())) $ n - 1

goSum = mySum (0, ())

-- Ответ
-- В первом аргументе будут накапливаться отложенные вычисления, потому что (x+y,z) 
-- уже является слабой головной нормальной формой, т.е. $! - в данном случае 
-- вообще ни на что не влияет.
-- Во втором, понятное дело, происходит сопоставление, поэтому мы должны до 
-- конца просчитывать второй аргумент при каждом вызове.