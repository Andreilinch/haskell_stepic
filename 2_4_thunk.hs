-- Ленивость вычислений может приводить к некоторым проблемам.
-- Иногда в процессе работы с большим обьемом данных отложенные вычисления 
-- могут накопиться. 
-- Например мы хотим складывать элементы в списке произвольной длины. 
-- Если список содержит несколько миллионов элементов, все эти элементы
-- лежат в памяти, соединенные оператором сложения, и ждут когда они будут сложены
-- Утечки памяти очень частая проблемы в работе с большими данными в Хаскеле. 

-- Если мы обнаружили, что у нас возникает длинное отложенное вычисление, (thunk) 
-- нам нужно обьяснить компилятору, что его делать не надо. Для этого существует
-- специальный оператор seq, который нарушает ленивую семантику в Haskell

-- seq :: a -> b -> b    - seq определен как функция двух аргументов
-- seq _|_ b = _|_       - _|_ - основание, означает расходящееся вычисление
-- seq a b = b           - возвращает второй аргумент

-- то есть если первый аргумент seq расходится - он должен расходиться, если
-- первый аргумен вычисляется до значения, он просто возвращает второй аргумент,
-- игнорируя первый. То есть оператор форсирует вычисления своего первого аргумента

-- *Demo>  seq 1 2
-- 2

-- *Demo> seq undefined 2
-- *** Exception: Prelude.undefined

-- seq форсирует вычисление до WHNF

-- seq (undefined, undefined) 2
-- 2
-- нет расходимости, потому что пара (undefined, undefined) является WHNF

-- Задача
-- При вычислении каких из перечисленных ниже функций использование seq 
-- предотвратит нарастание количества невычисленных редексов при увеличении 
-- значения первого аргумента:

foo 0 x = x
foo n x = let x' = foo (n - 1) (x + 1)
          in x' `seq` x'

bar 0 f = f
bar x f = let f' = \a -> f (x + a)
              x' = x - 1
          in f' `seq` x' `seq` bar x' f'

baz 0 (x, y) = x + y
baz n (x, y) = let x' = x + 1
                   y' = y - 1
                   p  = (x', y')
                   n' = n - 1
               in p `seq` n' `seq` baz n' p

quux 0 (x, y) = x + y
quux n (x, y) = let x' = x + 1
                    y' = y - 1
                    p  = (x', y')
                    n' = n - 1
                in x' `seq` y' `seq` n' `seq` quux n' p

-- Разбор из комментов

-- 1. Функция foo. 
-- Тут можно сразу заметить как применен seq : x' `seq` x', что можно прочитать 
-- как - "вычислить x' перед тем как вычислить x'". Таким образом этот seq 
-- бессмысленный и эквивалентен просто вычислению x'. На содержание функции 
-- можно даже не смотреть.

-- 2. Функция bar.
-- Тут есть два места накопления редексов (если так можно выразиться):
-- Первое - это лямбда выражение f' = \a -> f (x + a),
-- которое разрастается в \a -> ... (\a -> (\a -> f (x + a))(x + a)) ...(x+a).
-- Тут seq не вызывает форсированного вычисления, так как лямбда выражение это 
-- уже WHNF, - а seq дальше WHNF не вычисляет.
-- И второе - это x' = x - 1.
-- Здесь seq приводит к вычислению, но все равно бесполезен, так как к 
-- вычислению x' приводит первая формула уравнения определения функции bar 0 f = f. 
-- Тут используется сопоставление с образцом (pattern matching), что требует 
-- сравнения первого аргумента с 0, а для этого фактический аргумент должен быть вычислен.
-- Таким образом применение seq в этой функции не играет роли.

-- 3. Функция baz.
-- Аналогично предыдущему случаю, с той лишь разницей, что тут не лямбда выражение, 
-- а пара (x', y') находится в WHNF.

-- 4. Функция quux.
-- Единственная функция где применения seq имеет эффект. В отличии от baz, тут 
-- seq применяется непосредственно к элементам пары (x', y') в отдельности и 
-- поэтому они вычисляются принудительно.