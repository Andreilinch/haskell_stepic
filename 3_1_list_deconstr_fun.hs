-- Существует два способа деконструровать списки
-- также как у пары есть функции fst и snd для извлечения - декострукции
-- элементов пары у списков есть аналогичные функции head и tail

-- Prelude> head [1, 2, 4]
-- 1

-- Prelude> tail [1, 2, 4]
-- [2,4]

-- С помощью этих базовых функций можем реализовать функцию second

second :: [a] -> a
second xs = head (tail xs)

-- либо в безточечном стиле

second' :: [a] -> a
second' = head . tail

-- мощным инструментом для декострукции списков является сопостовление с образцом
-- pattern matching

let head' ((:) x xs) = x -- ((:) x xs) - образец с оператором : в префиксном стиле

let tail' (x : xs) = xs -- (x : xs) - образец с оператором : в инфиксном стиле

-- так как x не используется в правой части, можем заменить его на _

let tail'' (_ : xs) = xs

-- можем также переписать нашу функцию second в стиле pattern matching

second'' :: [a] -> a
second'' (_ : xs) = head xs

-- можно полностью заменить head и tail на pattern matching!

second''' :: [a] -> a
second''' (_ : x : _) = x -- (_ : x : _) - в голову добавлено x : _ и еще раз в голову добавлено _ :

-- Задача:
-- Исследуйте тип функции

sndHead = snd . head

-- и разберитесь, каково ее поведение. Эту функцию можно реализовать, 
-- используя сопоставление с образцом
-- Отметьте те образцы, которые подходят для этой цели.

-- Ответ

-- *Main> sndHead = snd . head
-- *Main> :t sndHead
-- sndHead :: [(a, c)] -> c
-- *Main> sndHead [(23, 123), (1, 5), (32, 4)]
-- 123

-- функция возвращает второй элемент первой пары

-- 1. 
sndHead' ((,) y x : z) = x
-- sndHead' :: [(a, b)] -> b
-- *Main> sndHead' [(23, 123), (1, 5), (32, 4)]
-- 123
-- Подходит

-- 2. 
sndHead'' ((_, x) : _) = x
-- sndHead'' :: [(a, b)] -> b
-- *Main> sndHead' [(23, 123), (1, 5), (32, 4)]
-- 123
-- Подходит

-- 3.
sndHead''' ((,) y z : x) = x
-- sndHead''' :: [(a, b)] -> [(a, b)]
-- *Main> sndHead''' [(23, 123), (1, 5), (32, 4)]
-- [(1,5),(32,4)]
-- НЕ подходит

-- 4.
sndHead'''' ((:) ((,) _ x) y) = x
-- sndHead'''' :: [(a, b)] -> b
-- *Main> sndHead'''' [(23, 123), (1, 5), (32, 4)]
-- 123
-- Подходит

-- 5.
sndHead''''' ((,) ((:) _ _) x) = x
-- sndHead''''' :: ([a], b) -> b
-- Ошибка типов, не подходит

-- 6.
sndHead'''''' ((,) x y : z) = x
-- sndHead'''''' :: [(a, b)] -> a
-- *Main> sndHead'''''' [(23, 123), (1, 5), (32, 4)]
-- 23
-- НЕ подходит

