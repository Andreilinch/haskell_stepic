-- Рекурсивные определения функции над списками очень похожи
-- Часто реализуется одна и та же схема рекурсии - пустой список это терминируещее условие, 
-- не пустой список разделяется на голову и хвост и мы рекрсивно вызываем нашу функцию над
-- хвостом, а с головой выполняем некоторую операцию

import Prelude hiding (foldr)

sumList :: [Integer] -> Integer
sumList [] = 0
sumList (x:xs) = x + sumList xs

productList :: [Integer] -> Integer
productList [] = 1
productList (x:xs) = x * productList xs

concatList :: [[a]] -> [a]
concatList [] = []
concatList (x:xs) = x ++ concatList xs

-- схема рекурсии одна и та же:
-- первое место это инициализирующее значение, а второе место это бинарная функция, 
-- своя для каждой функции "+" "*" "++" 
-- таким образом можно абстрагироваться по этим двум сущностям

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f ini []      = ini                   -- сворачивающая функция f, инициализирующее значение и список
                                            -- на пустом списке возвращаем значение
foldr f ini (x:xs)  = x `f` foldr f ini xs  -- если список не пустой - в операторном стиле вызываем функцию f
                                            -- первый аргумент x - голова списка, второй - функция на хвосте 
                                            -- параметры функции не меняются

-- теперь перепишем нашу функцию через свертку
sumList' :: [Integer] -> Integer
-- sumList xs = foldr (+) 0 xs

-- либо в без точечном стиле

sumList' = foldr (+) 0

-- тоже для concatList
concatList' :: [[a]] -> [a]
concatList' = foldr (++) []

-- Сворачивающая функция может быть не только оператором но и более сложной функцией
-- Например нам нужно посчитать сумму квадратов положительныйх элементов списка

sumPositiveSquares :: [Integer] -> Integer
sumPositiveSquares = foldr (\x s -> if x > 0 then x^2 + s else s) 0     -- x это элемент списка
                                                                        -- s - результат свертки хвоста списка

-- *Main> sumPositiveSquares [1, 2, (-4)]
-- 5

-- можно сделать без лямбды:
-- sumPositiveSquares = foldr f 0 where
--    f x s = if x > 0 then x^2 + s else s

-- Правой сверткой эито называется потому что работает она по следующему алгоритму

-- foldr (-) 5 [1, 2, 3] == (1 - (2 - (3 - 5)))
-- *Main> foldr (-) 5 [1, 2, 3]
-- -3
-- (1 - (2 - (3- 5)))

-- в общем виде
-- foldr f ini 1:2:3:[] -- запись списка через конструкторы
-- -> 1 `f` foldr f ini (2:3:[])
-- -> 1 `f` (2 `f` foldr f ini (3:[]))
-- -> 1 `f` (2 `f` (3 `f` foldr f ini [])))
-- -> 1 `f` (2 `f` (3 `f` ini)))

-- Какой функции стандартной библиотеки, суженной на списки, эквивалентно выражение foldr (:) []?
-- id

-- Какой функции стандартной библиотеки эквивалентно выражение foldr const undefined?
-- head
