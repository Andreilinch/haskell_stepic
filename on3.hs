-- Реализуйте функцию on3, имеющую семантику, схожую с on, но принимающую в качестве первого аргумента трехместную функцию.
-- Например, сумма квадратов трех чисел может быть записана с использованием on3 так:
-- GHCi> let sum3squares = (\x y z -> x+y+z) `on3` (^2)
-- GHCi> sum3squares 1 2 3
-- 14

on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = op (f x) (f y) (f z)

-- Коменты
--  применение функций в Haskell (и в lambda calculus вообще) левоассоциативно: f x f y f z эквивалентно ((((f x) f) y)  f) z, при право-ассоциативности было бы f (x (f (y (f z))), но никак не op (f x) (f y) (f z). Правила ассоциативности и служат для вывода типа выражения, можно написать просто
--  on3 op f x y z = op (f x) (f y) (f z) и тип функции будет автоматически выведен как (t1 -> t1 -> t1 -> t2) -> (t3 -> t1) -> t3 -> t3 -> t3 -> t2
--
--  То есть, в решении можно опустить явное определение типа on3 которое там вставлено по умолчанию.
--
--  Почему не работает вариант on3 op f = \x y z -> op $ (f x $ f y $ f z) ?
--   у опреатора применения функции (пробел) наивысший приоритет, поэтому сначала вычисляются выражения f x, f y и f z. Далее, так как у оператора правая ассоциативность, вычисляется выражение со вторым оператором в скобках (f y f z). Так как выражение f y имеет тип b и выражение f z также имеет тип b, то возникает ошибка (оператор ожидает функцию в качестве первого аргумента). 
