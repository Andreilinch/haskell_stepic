-- Для сложный генераций арифмметических последовательностей в Haskell сущеествует особый 
-- синтаксический сахар - list comprehension 

-- Определим некоторый список
let xs = [1..20]

-- Слева от черты выражение, которое мы хотим получить, справа - правило для перебора списка или генератор
[x^2 | x <- xs]

-- Prelude> [x^2 | x <- xs]
-- [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400]

-- мы можем добавлять дополнительные условия на х в правой части

-- Prelude>  [x^2 | x <- xs, x^2 > 200]
-- [225,256,289,324,361,400]

-- Prelude> [(x, y) | x <- [1, 2], y <- [1, 2]] 
-- [(1,1),(1,2),(2,1),(2,2)]

-- для порядка списка используется правило - чем генератор правее тем чаще он меняется

-- С помощью list comprehension найдем Пифагоровы тройки

[(x, y, z) | x <-xs, y <- xs, z <- xs, x^2+y^2==z^2, x<=y]

-- Prelude> [(x, y, z) | x <-xs, y <- xs, z <- xs, x^2+y^2==z^2, x<=y]
-- [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]

