-- помимо сопоставления с образцом есть способ рекурсивно перебирать вест список
-- для доступа к его элементам. 

module Demo where

import Prelude hiding (length, (++), null) -- для того чтобы переопределить стандартные функции

length :: [a] -> Int
length []     = 0
length (x:xs) = 1 + length xs -- (x:xs) - разделяем список на голову и хвост и
                              -- рекурсивно вызываем length на хвосте

-- теперь напишем функцию конкатенации двух списков

(++) :: [a] -> [a] -> [a]
[] ++ ys     = ys           -- если первый список пустой
(x:xs) ++ ys = x : (xs ++ ys) -- если нет рекурсивный вызов, можно без ()

-- напишем функцию, определяющую является ли список пустым

null :: [a] -> Bool
null [] = True
null _  = False


