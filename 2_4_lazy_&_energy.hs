-- В императивных языках порядок вычисления определяется последовательностью
-- инструкций. В ФЯ никаких инструкций нет, поэтому не понятно, что называть
-- порядком вычисления?

-- Вычисления в ФЯ происходят по средствам редукции выражения. С точки зрения
-- порядка, на процесс редукции можно смотреть несколькими путями.

module Demo where

sumIt :: Int -> Int -> Int
sumIt x y = x + y

-- *Demo> sumIt (2 + 3) 5
-- 10

-- Каким образом мы получили этот результат? Существуют две основные стратегии
-- вычислений

-- 1. Энергичная (применяемая в импертивных языках)
-- Сначала вычислится аргумент функции (2 + 3), потом вызывается функция sumIt
-- {
--   sumIt (2 + 3) 5
--   sumIt 5 5 - сначала вычисляем значение первого аргумента, потом вызов функции
--   5 + 5
--   10
-- }

-- 2. Ленивая (принята в Haskell)
-- Сначала подстановка (2 + 3), потом вычисление
-- {
--   sumIt (2 + 3) 5 - делаем подстановку
--   (2 + 3) + 5 - вычисляем значение первого аргумента
--   5 + 5
--   10
-- }

-- Важно сказать, что выражение, которое может быть упрощено называется redex
-- - сокращение от REDucible EXpression.
-- В sumIt (2 + 3) 5 имеются два redex'a - первый работает со втроенным опреатором
-- "+". Это выражение непосредственно вычисляется и дает результат. Второй это
-- применение функции к своим аргументам
-- То есть в ситуации когда у нас есть несколько redex, мы можем реализовывать 
-- разные стратегии вычислений.

-- Важным свойством чистых ФЯ является независимость результата вычисления программы от 
-- выбранной стратегии те программы, которые всегда терминируются [при любой стратегии] 
-- имеют не зависящий от стратегии результат.

-- В императивных языках это свойство не всегда выполняется из-за
-- наличия изменяемых переменных

-- Задача
-- Предположим, что стандартные функции определены следующим образом:

id x = x
const x y = x
max x y = if x <= y then y else x
infixr 0 $
f $ x = f x

-- Сколько редексов имеется в следующем выражении
-- const $ const (4 + 5) $ max 42

-- Примечание. Мы определили шаг вычислений как подстановку тела функции вместо
-- ее имени с заменой всех ее формальных параметров на фактически переданные ей 
-- выражения. Редексом при этом мы называем подвыражение, над которым можно 
-- осуществить подобный шаг.

-- Ответ 3

-- Полезный разбор пользователя Extrn из комментов:

-- 1. Редекс - это часть выражения, которая полностью соответствует левой части 
--    какого-нибудь определения
-- 2. Количество редексов в выражении это НЕ количество шагов, требуемых для его 
--    окончательного вычисления, это количество вариантов подстановки, одним из 
--    которых мы можем воспользоваться здесь и сейчас
-- Например, выражение

max 5 $ const 3 9

-- содержит два редекса: 
-- мы можем подставить выражение const 3 9 в определение функции const и получим

const x y = x
const 3 9 = 3

-- либо можем подставить выражение max 5 $ const 3 9 в определение оператора $ 
-- и получим

f $ x = f x
(max 5) $ (const 3 9) = (max 5) (const 3 9)

-- Итого имеем два варианта для первого шага подстановки

max 5 $ 3           -- выполнили подстановку const
(max 5) (const 3 9) -- выполнили подстановку $

-- Не важно, какой путь выбрал бы Haskell, нас просят посчитать все возможные 
-- варианты для первого шага.

-- Теперь вернемся к выражению из задания
-- Для начала расставим скобки для удобства

const $ ((const (4 + 5)) $ (max 42))

-- Именно так бы их расставил (у себя в голове) Haskell согласно правилам для 
-- оператора $ (указано в задании - наименьший приоритет, правоассоциативный) 
-- и операции применения (наивысший приоритет, левоасоциативный)
-- Что мы можем здесь сделать? 

-- Можем осуществить подстановку первого оператора $
const $ ((const (4 + 5)) $ (max 42)) = const ((const (4 + 5)) $ (max 42))

-- Второго оператора $
(const (4 + 5)) $ (max 42) = (const (4 + 5)) (max 42)

-- и сложения
4 + 5 = 9

-- Определение сложения не дано в задании, но очевидно, что такое определение 
-- существует, и что это выражение тоже требует подстановки, ведь как-то мы 
-- должны из 4 + 5 получить 9.
-- В итоге имеем три варианта для первого шага подстановки

const ((const (4 + 5)) $ (max 42)) -- выполнили подстановку первого $
const $ ((const (4 + 5)) (max 42)) -- выполнили подстановку второго $
const $ ((const 9) $ (max 42))     -- выполнили подстановку сложения

-- А что насчет const и max? С ними мы на первом шаге не можем делать ничего. 
-- Определение обеих функций содержит два параметра, а в представленном 
-- выражении функции применены только частично, подстановку выполнить не получится