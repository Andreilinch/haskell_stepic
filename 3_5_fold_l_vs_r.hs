-- Из-за своей структуры левая свертка очень плохо ведет себя на бесконечных списках
-- так как сразу же вызывает себя в правой части (головной редекс содержит рекурсивный вызов функции)
-- поэтому будет все время поставляться определение функции foldl
-- првая свертка останавливается на бесконечном списке

-- Например можно реализовать функцию any на бесконечном списке с помощью правой свертки:

any' :: (a -> Bool) -> [a] -> Bool
any' p = foldr (\x b-> p x || b) False

-- *Main> any (<5) [1 .. ]
-- True

-- В процессе выполнения свертки можно использовать не одну сворачивающую функцию

-- Преположим, что нам нужно за один проход по списку с помощью одной свертки вычислить 
-- сумму элементов списка и произведение элементов списка

foldr (\x (sum, prod) -> (x + sum, x * prod)) (0, 1) [1, 2, 3, 4]

-- *Main> foldr (\x (sum, prod) -> (x + sum, x * prod)) (0, 1) [1, 2, 3, 4]
-- (10,24)
