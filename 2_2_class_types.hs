-- Классы типов
-- Специальный полиморфизм устроен по-другому. Функция по-прежнему может вызываться на разных
-- типов данных, но каждый тип данных, который использует специальный полиморфизм должен 
-- обеспечивать реализацию соответствующего интерфейса для того, чтобы функция могла его 
-- вызывать. Этот интерфейс в хаскеле называется классом типов и класс типов описывает 
-- интерфейс целиком. И есть еще одно понятие – реализация класса типов, реализация 
-- представителя. Тип данных должен объявлять представителя класса типов, т.е. 
-- имплементировать соответствующий интерфейс. И после того, как имплементировал 
-- соответствующий интерфейс мы можем уже в специально полиморфную функцию такой тип данных передавать.
-- То есть функция специально полиморфна если для каждого типа, на значениях которого ее можно вызывать, имеется своя реализация этой функции.
-- Например:
-- Числовые константы в хаскеле имееют полиморфный тип
-- :t 7
-- 7 :: Num p => p  - символ следования разделяет выражение на две части
--       |       |_ непосредственно тип выражения ("7 имеет тип а")
--    контекст:
--    Num - имя интерфейса
--    a - тип применения интерфейса
--
-- 7 имеет тип а, но для этого типа а должен быть выстроен интерфейс Num

-- :t (>)
-- (>) :: Ord a => a -> a -> Bool
-- оператор принимает два аргумента и возвращает булево значение, однако контекст
-- ord a означает что тип а должен быть представителем класса ord

-- :t (> 7)
-- (> 7) :: (Ord a, Num a) => a -> Bool
-- теперь два элемента контекста
-- тоже для пары
-- :t (> (1, 7)
-- (> (1, 7)) :: (Ord a, Ord b, Num a, Num b) => (a, b) -> Bool)

-- :t (* 'c')
--
-- <interactive>:1:2: error:
--     • No instance for (Num Char) arising from a use of ‘*’
-- 'с' не является представителем класса типов Num

-- Задача
-- На нехватку какого представителя какого класса типов пожалуется интерпретатор при попытке вывести тип выражения
-- True + False * False
--
-- :t True + False * False
--
-- <interactive>:1:1: error:
--     • No instance for (Num Bool) arising from a use of ‘+’

-- Пример класса типов

class Eq a where
  (==) :: a -> a -> Bool -- в классе есть функция сравнения на равенство (реализации нет, только интерфейс)
  (/=) :: a -> a -> Bool -- сравнение на неравество

-- :t (==)
-- (==) :: Eq a => a -> a -> Bool
-- если подставить конкретные типы, контекст Eq пропадет
-- :t (== 'x')
-- (== 'x') :: Char -> Bool

-- Конкретный тип называется представителем (экземпляр = instance) класса типов если для него реализованы все 
-- функции, которые в классе типов обьявлены
-- сделаем какой-то конкретный тип представителем класса Eq

instance Eq Bool where  -- Bool подставится вместо а в класс
-- реализация сигнатуры равентсва
  True  == True  = True  
  False == False = True
  _     == _     = False  -- _ значит во всех остальных случаев
-- реализация неравенства
  x /= y = not (x == y)

-- можно записать реализацию неравенства прямо в класс, это допускается для тех реализаций
-- которые уже есть (по умолчанию)

class Eq' a where
  (==), (/=):: a -> a -> Bool
  x /= y = not (x == y)
  x == y = not (x /= y)

-- теперь реализация будет подхватываться из класса типов (либо равенство ибо неравентсво)
-- see minimal complete defifnition

-- в ООП определяют интерфейс для некоторого типа данных, там же где тип обьявляют
-- Суть в том, что если вы в ООП хотите предоставить функциональность интерфейса какому-то
-- классу, то у вас нет другого способа, кроме как реализовать этот интерфейс прямо в теле 
-- класса. Вы не можете взять какой-то класс, который уже существует, лежит в какой-то 
-- библиотеке и у вас нет его исходников, и сказать: "отныне это класс реализует интерфейс 
-- Comparable". Вам придется или взять исходники этого класса и дописать там реализацию всех 
-- функций из интерфейса, или наследоваться от этого класса и реализовать интерфейс в
-- наследнике.
-- В Хаскеле же вы можете взять любой тип и в любой момент сделать его представителем любого
-- класса типов ничего не меняя в определении самого типа. Попробуйте реализовать в Хаскеле 
-- класс типов Comparable (тот же самый Ord по сути) и сделать, например, тип Int 
-- представителем этого класса. Вы с легкостью это проделаете, не трогая объявления ни класса 
-- Int, ни вашего класса типов Comparable. В объектных языках такой фокус как правило невозможен.
