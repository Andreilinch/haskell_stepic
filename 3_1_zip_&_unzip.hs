-- https://stepik.org/lesson/8326/step/12?unit=1474
-- Есть функции у которых присутсвут несколько списочных аргументов
-- тогда сопоставление с образцом необходимо проводить по каждому
-- примером такой фунции является zip, которая принимает два списка и соединяет
-- их поэлементно и возвращая пару первых элементов и двух списков, пару вторых
-- элементов и так до того как один из списков не кончится

-- Prelude> zip [1, 3, 5] "ARBCA"
-- [(1,'A'),(3,'R'),(5,'B')]

module Demo where

import Prelude hiding (zip, zip3, unzip)

zip :: [a] -> [b] -> [(a,b)]
zip []      _     = []                  -- первое терминирующее условие - первый список пуст
zip as     []     = []                  -- второе терминирующее условие - второй список пуст
zip (a:as) (b:bs) = (a,b) : zip as bs   -- разбиваем оба списка на голову и хвост и головы соединяем
                                        -- в пару, а над хвостами опять вызываем zip

-- есть функция zip3, которая делает тоже самое для 3 списков и соответственно возвращает список троек (не пар)

zip3 :: [a] -> [b] -> [c] -> [(a,b,c)]
zip3 (a:as) (b:bs) (c:cs) = (a,b,c) : zip3 as bs cs
zip3 _      _      _      = []

-- есть также стандартная функция unzip

unzip :: [(a,b)]  -> ([a],[b])
unzip []           =  ([],[])           -- если пустой список - возвращаем пару пустых списков
unzip ((x, y):xys) =                    -- если не пустой отрываем от списка голову, которая является парой (x, y)
    let (xs, ys) = unzip xys            -- дальше на хвосте вызываем unzip рекурсивно
    in (x:xs, y:ys)                     -- добавляем элементы

