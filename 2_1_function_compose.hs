-- Пускай у нас есть две полиморфные функции f и g. Мы хоти описать оператор композиции этих функций. 
-- То есть такую функцию, которая принимает f и g, а возвращает функцию, которая берет
-- некоторый аргумент и применяет к нему функцию g, а потом к результату этого применения
-- применяет функцию f.

-- опишем в типах токой оператор
-- пусть f :: b -> c
-- посколько мы хотим применять функцию f к результату функции g, возвращаемым типом
-- должно быть b
-- g :: a -> b
-- и значение x :: a
-- Получается
-- f (g x) Аппликация (g x) имеет тип b, а все выражение с, но нам нужно получить функцию
-- из а в с, для этого нужно просто обстрагироваться по х, записав лямбда выражение

let compose f g = \x -> f (g x)

-- :t compose
-- compose :: (t1 -> t2) -> (t3 -> t1) -> t3 -> t2
-- мы определили функцию compose, но в хаскеле уже есть оператор, делающий тоже самое:
-- Оператор композиции функции
-- :info (.)
-- (.) :: (b -> c) -> (a -> b) -> a -> c   -- Defined in ‘GHC.Base’
-- infixr 9 . (9 приоритет, правая ассоциативность)

-- Функция пары пар из lambda_fun

sumFstFst' = (+) `on` (\pp -> fst $ fst pp)

-- имеет композицию функций fst, это можно переписать более компактно

sumFstFst'' = (+) `on` (fst . fst)

-- цепочка последовательных применений может быть заменена композицией

doIt x = f ( g (h x))

-- тоже самое что и 

doIt' = f . g . h
