-- Каррирование (от англ. currying, иногда — карринг) — преобразование функции от многих
-- аргументов в набор функций, каждая из которых является функцией от одного аргумента.
-- Возможность такого преобразования впервые отмечена в трудах Готтлоба Фреге, 
-- систематически изучена Моисеем Шейнфинкелем в 1920-е годы, а наименование получило по имени
-- Хаскелла Карри — разработчика комбинаторной логики, в которой сведение к функциям одного
-- аргумента носит основополагающий характер.

-- функция fst возвращает первый элемент пары

-- fst (1, 2)
-- 1

-- это функция также может быть рассмотрена как функция двух элементов, то есть она не каррирована
-- В чем смысл процедуры каррирования?
--
-- представим что у нас есть какая-то функция высшего порядка, например `on`
-- :t on
-- on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
-- `on` имеет такой тип, то есть в качеств первого элемента он ожидает функцию двух аргументов
-- то есть мы не можем вызвать `on` на не каррированной функции
-- :t fst `on` (^2)
-- <interactive>:1:1: error:
--     • Occurs check: cannot construct the infinite type:
--             b ~ (b -> c, b0)

-- в языке Хаскелль есть специальный комбинатор, который помогает сделать каррирование
-- :t curry fst `on` (^2)
-- curry fst `on` (^2) :: Num c => c -> c -> c
-- Как устроена функции curry?
-- Давайте попытаемся ее сконструировать
-- функция должна принимать некоторую функцию, заданную над парой (некаррированную) и два
-- аргумента, которые мы хотим использовать в этой паре:

let curry' f x y = f (x, y)

-- :t curry'
-- curry' :: ((a, b) -> t) -> a -> b -> t
-- в качестве первого аргумента принимем некаррированную функцию двух аргументов и превращаем ее
-- в каррированную, где аргумент передается последовательно

-- существует и обратная функция 
-- :t uncurry
-- uncurry :: (a -> b -> c) -> (a, b) -> c

-- Пример на задаче: 
-- Какому известному вам библиотечному оператору, конструктору или функции эквивалентно выражение curry id?
-- Чтобы легче было, понять можно потыкать в противоположный uncurry. А для этого нужно найти какую-нибудь функцию, которая принимает два аргумента вместо 
-- (некаррированной) пары. Например, возьмем обычный оператор (+):

-- :t (+)

-- :t uncurry (+)

-- uncurry (+) (5, 1)

-- Видно сразу что тут происходит. Раньше мы делали так: (+) 5 1
-- Сейчас все то же самое делаем с парой чисел. То же самое можно проделать с любой функцией, например, max, min и т.п.
-- Вывод: если функция принимала на вход пару, то при помощи curry мы создаем интерфейс, который позволяет принимать
-- отдельные аргументы. И в обратную сторону: uncurry позволяет функции принимать на вход пару вместо отдельных аргументов.

-- Ответ на задачу - Оператор (,) эквивалентен сurry id

-- Задача:
-- В модуле Data.Tuple стандартной библиотеки определена функция swap :: (a,b) -> (b,a), переставляющая местами элементы пары:
-- GHCi> swap (1,'A')
-- ('A',1)
-- Эта функция может быть выражена в виде:
-- swap = f (g h)
-- где f, g и h — некоторые идентификаторы из следующего набора:
-- curry uncurry flip (,) const
-- Укажите через запятую подходящую тройку f,g,h
--
-- uncurry, flip, (,)
-- так как итоговая функция - swap p = uncurry (flip (,)) p
-- flip (,) - возвращает функцию создания пары, в которой аргументы меняются местами. 
-- Такая функция может быть применена к двум значениям x и y: (flip (,)) 3 5 = (5, 3) и 
-- имеет вид b -> a -> (a, b), uncurry преобразует эту функцию вида a -> b -> c в функцию 
-- ((a, b) -> c), то есть полученная в результате flip функция b -> a -> (a, b) примет вид
-- (b, a) -> (a, b), что и представляет перестановку элементов в кортеже.
