-- Каррирование (от англ. currying, иногда — карринг) — преобразование функции от многих
-- аргументов в набор функций, каждая из которых является функцией от одного аргумента.
-- Возможность такого преобразования впервые отмечена в трудах Готтлоба Фреге, 
-- систематически изучена Моисеем Шейнфинкелем в 1920-е годы, а наименование получило по имени
-- Хаскелла Карри — разработчика комбинаторной логики, в которой сведение к функциям одного
-- аргумента носит основополагающий характер.

-- функция fst возвращает первый элемент пары

-- fst (1, 2)
-- 1

-- это функция также может быть рассмотрена как функция двух элементов, то есть она не каррирована
-- В чем смысл процедуры каррирования?
--
-- представим что у нас есть какая-то функция высшего порядка, например `on`
-- :t on
-- on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
-- `on` имеет такой тип, то есть в качеств первого элемента он ожидает функцию двух аргументов
-- то есть мы не можем вызвать `on` на не каррированной функции
-- :t fst `on` (^2)
-- <interactive>:1:1: error:
--     • Occurs check: cannot construct the infinite type:
--             b ~ (b -> c, b0)

-- в языке Хаскелль есть специальный комбинатор, который помогает сделать каррирование
-- :t curry fst `on` (^2)
-- curry fst `on` (^2) :: Num c => c -> c -> c
-- Как устроена функции curry?
-- Давайте попытаемся ее сконструировать
-- функция должна принимать некоторую функцию, заданную над парой (некаррированную) и два
-- аргумента, которые мы хотим использовать в этой паре:

let curry' f x y = f (x, y)

-- :t curry'
-- curry' :: ((a, b) -> t) -> a -> b -> t
-- в качестве первого аргумента принимем некаррированную функцию двух аргументов и превращаем ее
-- в каррированную, где аргумент передается последовательно

-- существует и обратная функция 
-- :t uncurry
-- uncurry :: (a -> b -> c) -> (a, b) -> c

-- Пример на задаче: 
-- Какому известному вам библиотечному оператору, конструктору или функции эквивалентно выражение curry id?
-- Чтобы легче было, понять можно потыкать в противоположный uncurry. А для этого нужно найти какую-нибудь функцию, которая принимает два аргумента вместо 
-- (некаррированной) пары. Например, возьмем обычный оператор (+):

-- :t (+)

-- :t uncurry (+)

-- uncurry (+) (5, 1)

-- Видно сразу что тут происходит. Раньше мы делали так: (+) 5 1
-- Сейчас все то же самое делаем с парой чисел. То же самое можно проделать с любой функцией, например, max, min и т.п.
-- Вывод: если функция принимала на вход пару, то при помощи curry мы создаем интерфейс, который позволяет принимать
-- отдельные аргументы. И в обратную сторону: uncurry позволяет функции принимать на вход пару вместо отдельных аргументов.

-- Ответ на задачу - Оператор (,) эквивалентен сurry id
