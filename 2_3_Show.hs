-- Класс Show имеет метод show
-- берем некоторе значение и возвращаем строку

-- :t show
-- show :: Show a => a -> String

-- show 5.0
-- "5.0"

-- show [1, 2]
-- "[1,2]"

-- Есть обратная операчия за которую отвечает класс Read
-- :t read
-- read :: Read a => String -> a

-- НО, есть нюанс
-- если мы просто напишем 

-- read "6"
-- *** Exception: Prelude.read: no parse

-- получим сообщение об ошибки
-- проблема в том что функция read полиморфна по возвращаемому значаню
-- функция не понимает из какого типа эта 6 - Int, Integer и тд

-- Нужно снять полиморфизм типизировав все выражение

-- read "6" :: Int
-- 6

-- read "[1,2]" :: [Double]
-- [1.0,2.0]

-- Есть более удобная функция для синтаксического разбора

--reads "5 rings" :: [(Int,String)]
-- [(5," rings")]

-- Эта пара явлется единственным элементом списка. Список нужен при различных вариантах
-- синтаксического разбора, которые запишутся в список

-- Несмешная задача
-- Имея функцию ip = show a ++ show b ++ show c ++ show d определите значения
-- a, b, c, d так, чтобы добиться следующего поведения:
-- GHCi> ip
-- "127.224.120.12"

-- через новый тип:
newtype AddDotAtEnd = AddDotAtEnd Int

instance Show AddDotAtEnd where
  show (AddDotAtEnd s) = show s ++ "."

  a = AddDotAtEnd 127
  b = AddDotAtEnd 224
  c = AddDotAtEnd 120
  d = 12

-- ЛИБО

a = 12
b = 7.22
c = 4.1
d = 20.12

-- мда...
