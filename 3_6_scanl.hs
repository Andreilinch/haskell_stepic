-- Для получения накапливающихся в процессе свертки промежуточным значениям используется функция scan
-- Левая свертка на списке [1, 2, 3] работает так
-- foldl f ini [1, 2, 3] ~>> ((ini `f` 1) `f` 2) `f` 3
-- мы хотим получить список из этих промежуточных значений:
-- [ini, ini `f` 1, (ini `f` 1) `f` 2), ((ini `f` 1) `f` 2) `f` 3]

scanl' :: (b -> a -> b) -> b -> [a] -> [b]
scanl' f ini [] = [ini]
scanl' f ini (x:xs) = ini : scanl' f (ini `f` x) xs   -- повторяем реализацию левой cвертки
                                                      -- но конктенируем ее с ini

-- *Main> scanl (*) 1 [1 .. 10]
-- [1,1,2,6,24,120,720,5040,40320,362880,3628800]

-- получили первые 10 значкений функции факториал

-- левое скинирование в отличие от левой свертки может работать с бесконечеными списками
-- Функция бесконечных факториалов

facs :: (Num a, Enum a) => [a]
facs = scanl (*) 1 [1.. ]

-- можем обратиться к 5-ому элементу
-- *Main> facs !! 5
-- 120

-- анкалогично можно сделать для суммы
partialSum :: Num a => [a] -> [a]
partialSum = scanl (+) 0

-- *Main> partialSum [1.. 10]
-- [0,1,3,6,10,15,21,28,36,45,55]

-- с помощью этих функций можно, например, оценить сходимость редукции
-- посмотим как сумма ряда обратных факториалов сходится к числу е

partialSum $ map (**(-1)) facs -- бесконечный список частичных сумм обратных факториалов

-- *Main> take 15 $ partialSum $ map (**(-1)) facs
-- [0.0,1.0,2.0,2.5,2.6666666666666665,2.708333333333333,2.7166666666666663,2.7180555555555554,
-- 2.7182539682539684,2.71827876984127,2.7182815255731922,2.7182818011463845,2.718281826198493,
-- 2.7182818282861687,2.7182818284467594]




