-- Функция обладает полиморфным поведением если может быть вызвана на значениях разных типов

-- Выделяют два типа полиморфизма
-- Парметрический: код функции одинаков для всех типов, на которых можно вызывать функцию
-- Специальный: для каждого типа для которого допустим вызов функции имеется своя собственная
-- ее реализация

let id x = x

-- тип такой функции t -> t 
-- то есть переменная типа t означает, что функция может быть вызвана на любом типе

-- Например, функция, вызванная на значении True будет иметь тип Bool
-- :t id True 
-- :: Bool

-- Но какой тип будет у следующего выражения?
-- :t (id id)
-- :: t -> t
-- Применение внешней id будет возвращать тип: (t -> t) -> (t -> t), но функция, примененная
-- к дному своему аргументу становится арностью на единицу меньше и возвращает функцию
-- одного аргумента, внутренню id!

let k x y = x

-- Функция всегда возвращает первый аргумент, полность игнорируя второй
-- Тип такой функции
-- :: t1 -> t -> t1

-- Функция undefined прерывающая программу в любом месте вызова, тоже имеет тип
-- :: a
-- то есть indefined подходит для любого типа
-- также ведет себя и функция error
-- :t error "Код ошибки"
-- :: error "Код ошибки" :: a
-- :t error
-- error [Char] -> a
-- только с прерыванием программы можно создовать обьекты наивысшей степени полиморфизма

-- Задача:
-- Напишите функцию трех аргументов getSecondFrom, полиморфную по каждому из них, 
-- которая полностью игнорирует первый и третий аргумент, а возвращает второй. Укажите ее тип.
-- GHCi> getSecondFrom True 'x' "Hello"
-- 'x'
-- GHCi> getSecondFrom 'x' 42 True 
-- 42

getSecondFrom :: p1 -> p2 -> p3 -> p2
getSecondFrom x y z = y

-- Задача:
-- Сколько разных всегда завершающихся функций с типом a -> a -> b -> a -> a можно реализовать?
-- Две функции одинаковой арности считаются разными, если существует набор значений их аргументов, на котором они дают разные результирующие значения.
-- Я так понимаю основной вопрос, который возникает - почему не бесконечно?
-- Я понимаю так, что так как тут типы - переменные, то мы не можем выдать какое-то иное значение кроме переданного. Например, тип a может быть Int и тогда мы можем написать бесконечно функций вида:
--
-- f0 a b c d = a + 1
-- f1 a b c d = a + 2
-- ...
-- fn a b c d = a + n
--
-- Но тип a может быть не только типа Int, а например Char и тогда операция a + 1 не будет корректной из-за несоответствия типов.
-- Таким образом мы не можем произвести никакую операцию с такими полиморфными типами, потому что мы не знаем заранее конкретный тип. Остается выдать само значение, - в этом случае оно гарантированно будет корректно. А таких вариантов только 3, так как у нас только 3 переменных типа a.

-- Степень полимофизма функции можно ограничить с помощью явного указания ее типа

mono :: Char -> Char
mono x = x

-- Функция является мономорфной. Функция id работала с произволтным типом, а наша 
-- функция mono работает только с значениями типа Char

-- Можно также частично ограничить полиморфизм функции

semiMono :: Char -> a -> Char
semiMono x y = x 

-- первый элемент всегда Char, а второй может быть любым (a), то есть функция мономорфна по
-- первому аргументу

-- разрешение типов в haskell происходит по алгоритму Хиндли — Милнера

